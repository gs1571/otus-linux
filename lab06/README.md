# Bash, awk, sed, grep и другие

## Домашнее задание

Написать скрипт для крон, который раз в час присылает на заданную почту:
- X IP адресов (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта
- Y запрашиваемых адресов (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта
- все ошибки c момента последнего запуска
- список всех кодов возврата с указанием их кол-ва с момента последнего запуска
в письме должно быть:
- прописан обрабатываемый временной диапазон
- реализована защита от мультизапуска
Критерии оценки:
- трапы и функции, а также sed и find +1 балл

Скрипт - [httpdlog_analyzer.sh](httpdlog_analyzer.sh)

## Полезная информация

### Hot keys

* **Tab** или **Ctrl+1** - автодополнение строки
* **Ctrl+a** **Ctrl+e** - возврат курсора в начало строки, переход в конец строки
* **Alt+f**, **Alt+b** - перемещение на слово вперед, на слово назад
* **Ctrl+j** - возврат каретки (он же Enter)
* **Ctrl+l** - очищает экран
* **Ctrl+w** - удаляет слово до курсора (при этом копируй его в буфер обмена)
* **Ctrl+y** - вставить содержимое из буфера
* **Ctrl+u** - удаляет всю строку до курсора
* **Ctrl+k** - удаляет всю строку после курсора

### Поиск по истории

* Ctrl + r - поиск по строке, повторный Ctrl + r - цикличный поиск по истории
* Ctrl + r дважды - поиск по последней поисковой строке

Во время поиска:
* Ctrl + j - закончить поиск по истории
* Ctrl + g - закончить поиск и вернуть строку к прежнему состоянию

### Подсказки

`n1 -eq n2` Возвращает истинное значение, если n1 равно n2.  
`n1 -ge n2` Возвращает истинное значение, если n1 больше или равно n2.  
`n1 -gt n2` Возвращает истинное значение, если n1 больше n2.  
`n1 -le n2` Возвращает истинное значение, если n1 меньше или равно n2.  
`n1 -lt n2` Возвращает истинное значение, если n1 меньше n2.  
`n1 -ne n2` Возвращает истинное значение, если n1 не равно n2.  

`str1 = str2` Проверяет строки на равенство, возвращает истину, если строки идентичны.  
`str1 != str2` Возвращает истину, если строки не идентичны.  
`str1 < str2` Возвращает истину, если str1 меньше, чем str2.  
`str1 > str2` Возвращает истину, если str1 больше, чем str2.  
`-n str1` Возвращает истину, если длина str1 больше нуля.  
`-z str1` Возвращает истину, если длина str1 равна нулю.  

> Операторы `>` и `<` необходимо экранировать

`-d file` Проверяет, существует ли файл, и является ли он директорией.  
`-e file` Проверяет, существует ли файл.  
`-f file` Проверяет, существует ли файл, и является ли он файлом.  
`-r file` Проверяет, существует ли файл, и доступен ли он для чтения.  
`-s file` Проверяет, существует ли файл, и не является ли он пустым.  
`-w file` Проверяет, существует ли файл, и доступен ли он для записи.  
`-x file` Проверяет, существует ли файл, и является ли он исполняемым.  
`file1 -nt file2` Проверяет, новее ли file1, чем file2.  
`file1 -ot file2` Проверяет, старше ли file1, чем file2.  
`-O file` Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.  
`-G file` Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.  

IFS (Internal Field Separator) по умолчанию:
* space
* tab
* new line

`IFS=$'\n'` - разделитеть - new line  
`IFS=:` - разделить - символ `:`  

```bash
if CONDITION
then
    COMMANDS
elif CONDITION
then
    COMMANDS
else CONDITION
    COMMANDS
fi
```
```bash
for var in list
do
    COMMANDS
done > output
```
```bash
for (( i=1; i <= 10; i++ ))
do
    COMMANDS
done
```
### sed

`sed options file` - синтаксис  
`'s/original text/sabstitute text'` - замена текста  
`-e` - несколько операций, через ;  
`-f` - чтение из файла
`s/pattern/replacement/flags`, flags:
 * цифра - порядковый номер вхождения
 * **g** - все вхождения
 * **p** - вывести содержимое исходной строки
 * **w** - записать в файл  

`$ sed 's!/bin/bash!/bin/csh!' /etc/passwd` - замена символа разделителя, первый после s  
`$ sed '2s/test/another test/' myfile` - номер строки для обработки  
`$ sed '2,3s/test/another test/' myfile` - диапазон строк  
`$ sed '2,$s/test/another test/' myfile` - начиная с 2 и до конца  
`$ sed '/likegeeks/s/bash/csh/' /etc/passwd` - шаблон строки в которой надо сделать замену  
`$ sed '3d' myfile` - удаление строки 3
`$ sed '/test/d' myfile` - удаление по шаблону  
`$ sed '/second/,/fourth/d' myfile` - удаление строк по шаблонам и всех между ними
`$ echo "Another test" | sed 'a\First test '` - вставка текста до строки
`$ echo "Another test" | sed 'i\First test '` - вставка текста после строки
`$ sed '3c\This is a modified line.' myfile` - замена целой строки  
`$ sed '3r newfile' myfile` - вставка содержимого файла newfile после третьей строки  
`$ sed '/test/r newfile' myfile` - вставка после строки подходящий под шаблон  

### awk

`-F fs` — позволяет указать символ-разделитель для полей в записи.  
`-f file` — указывает имя файла, из которого нужно прочесть awk-скрипт.  
`-v var=value` — позволяет объявить переменную и задать её значение по умолчанию, которое будет использовать awk.  
`-mf N` — задаёт максимальное число полей для обработки в файле данных.  
`-mr N` — задаёт максимальный размер записи в файле данных.  
`-W keyword` — позволяет задать режим совместимости или уровень выдачи предупреждений awk.  

`FIELDWIDTHS` — разделённый пробелами список чисел, определяющий точную ширину каждого поля данных с учётом разделителей полей.  
`FS` — уже знакомая вам переменная, позволяющая задавать символ-разделитель полей.  
`RS` — переменная, которая позволяет задавать символ-разделитель записей.  
`OFS` — разделитель полей на выводе awk-скрипта.  
`ORS` — разделитель записей на выводе awk-скрипта.  

`ARGC` — количество аргументов командной строки.  
`ARGV` — массив с аргументами командной строки.  
`ARGIND` — индекс текущего обрабатываемого файла в массиве ARGV.  
`ENVIRON` — ассоциативный массив с переменными окружения и их значениями.  
`ERRNO` — код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов.  
`FILENAME` — имя входного файла с данными.  
`FNR` — номер текущей записи в файле данных.  
`IGNORECASE` — если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов.  
`NF` — общее число полей данных в текущей записи.  
`NR` — общее число обработанных записей.  

`awk 'BEGIN {print "The File Contents:"}{print $0} END {print "End of the File"}' myfile` - блок вначале и в конце  
`awk 'BEGIN{FIELDWIDTHS="3 5 2 5"} {print $1,$2,$3,$4}' testfile`  
```
$ awk '{
if ($1 > 20)
{
x = $1 * 2
print x
} else
{
x = $1 / 2
print x
}}' testfile
```
`$ awk '{if ($1 > 20) print $1 * 2; else print $1 / 2}' testfile`  

```
$ awk '{
total = 0
i = 1
while (i < 4)
{
total += $i
i++
}
avg = total / 3
print "Average:",avg
}' testfile
```
```
$ awk '{
total = 0
for (i = 1; i < 4; i++)
{
total += $i
}
avg = total / 3
print "Average:",avg
}' testfile
```

### printf

`%[modifier]control-letter`

`c` — воспринимает переданное ему число как код ASCII-символа и выводит этот символ.  
`d` — выводит десятичное целое число.  
`i` — то же самое, что и d.   
`e` — выводит число в экспоненциальной форме.  
`f` — выводит число с плавающей запятой.  
`g` — выводит число либо в экспоненциальной записи, либо в формате с плавающей запятой, в зависимости от того, как получается короче.  
`o` — выводит восьмеричное представление числа.  
`s` — выводит текстовую строку.  
